{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nexport const resolveFetch = customFetch => {\n  let _fetch;\n\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === 'undefined') {\n    _fetch = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return import('@supabase/node-fetch').then(_ref => {\n        let {\n          default: fetch\n        } = _ref;\n        return fetch(...args);\n      });\n    };\n  } else {\n    _fetch = fetch;\n  }\n\n  return function () {\n    return _fetch(...arguments);\n  };\n};\nexport const resolveResponse = () => __awaiter(void 0, void 0, void 0, function* () {\n  if (typeof Response === 'undefined') {\n    // @ts-ignore\n    return (yield import('@supabase/node-fetch')).Response;\n  }\n\n  return Response;\n});\nexport const recursiveToCamel = item => {\n  if (Array.isArray(item)) {\n    return item.map(el => recursiveToCamel(el));\n  } else if (typeof item === 'function' || item !== Object(item)) {\n    return item;\n  }\n\n  const result = {};\n  Object.entries(item).forEach(_ref2 => {\n    let [key, value] = _ref2;\n    const newKey = key.replace(/([-_][a-z])/gi, c => c.toUpperCase().replace(/[-_]/g, ''));\n    result[newKey] = recursiveToCamel(value);\n  });\n  return result;\n};\n/**\n * Determine if input is a plain object\n * An object is plain if it's created by either {}, new Object(), or Object.create(null)\n * source: https://github.com/sindresorhus/is-plain-obj\n */\n\nexport const isPlainObject = value => {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,OAAO,MAAMA,YAAY,GAAIC,WAAD,IAA+B;EACzD,IAAIC,MAAJ;;EACA,IAAID,WAAJ,EAAiB;IACfC,MAAM,GAAGD,WAAT;EACD,CAFD,MAEO,IAAI,OAAOE,KAAP,KAAiB,WAArB,EAAkC;IACvCD,MAAM,GAAG;MAAA,kCAAIE,IAAJ;QAAIA,IAAJ;MAAA;;MAAA,OACP,OAAO,sBAAP,EAAsCC,IAAtC,CAA2C;QAAA,IAAC;UAAEC,OAAO,EAAEH;QAAX,CAAD;QAAA,OAAwBA,KAAK,CAAC,GAAGC,IAAJ,CAA7B;MAAA,CAA3C,CADO;IAAA,CAAT;EAED,CAHM,MAGA;IACLF,MAAM,GAAGC,KAAT;EACD;;EACD,OAAO;IAAA,OAAaD,MAAM,CAAC,YAAD,CAAnB;EAAA,CAAP;AACD,CAXM;AAaP,OAAO,MAAMK,eAAe,GAAG,MAAqCC;EAClE,IAAI,OAAOC,QAAP,KAAoB,WAAxB,EAAqC;IACnC;IACA,OAAO,CAAC,MAAM,OAAO,sBAAP,CAAP,EAA8CA,QAArD;EACD;;EAED,OAAOA,QAAP;AACD,CAPmE,CAA7D;AASP,OAAO,MAAMC,gBAAgB,GAAIC,IAAD,IAAuC;EACrE,IAAIC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAJ,EAAyB;IACvB,OAAOA,IAAI,CAACG,GAAL,CAAUC,EAAD,IAAQL,gBAAgB,CAACK,EAAD,CAAjC,CAAP;EACD,CAFD,MAEO,IAAI,OAAOJ,IAAP,KAAgB,UAAhB,IAA8BA,IAAI,KAAKK,MAAM,CAACL,IAAD,CAAjD,EAAyD;IAC9D,OAAOA,IAAP;EACD;;EAED,MAAMM,MAAM,GAAwB,EAApC;EACAD,MAAM,CAACE,OAAP,CAAeP,IAAf,EAAqBQ,OAArB,CAA6B,SAAiB;IAAA,IAAhB,CAACC,GAAD,EAAMC,KAAN,CAAgB;IAC5C,MAAMC,MAAM,GAAGF,GAAG,CAACG,OAAJ,CAAY,eAAZ,EAA8BC,CAAD,IAAOA,CAAC,CAACC,WAAF,GAAgBF,OAAhB,CAAwB,OAAxB,EAAiC,EAAjC,CAApC,CAAf;IACAN,MAAM,CAACK,MAAD,CAAN,GAAiBZ,gBAAgB,CAACW,KAAD,CAAjC;EACD,CAHD;EAKA,OAAOJ,MAAP;AACD,CAdM;AAgBP;;;;;;AAKA,OAAO,MAAMS,aAAa,GAAIL,KAAD,IAA2B;EACtD,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;IAC/C,OAAO,KAAP;EACD;;EAED,MAAMM,SAAS,GAAGX,MAAM,CAACY,cAAP,CAAsBP,KAAtB,CAAlB;EACA,OACE,CAACM,SAAS,KAAK,IAAd,IACCA,SAAS,KAAKX,MAAM,CAACW,SADtB,IAECX,MAAM,CAACY,cAAP,CAAsBD,SAAtB,MAAqC,IAFvC,KAGA,EAAEE,MAAM,CAACC,WAAP,IAAsBT,KAAxB,CAHA,IAIA,EAAEQ,MAAM,CAACE,QAAP,IAAmBV,KAArB,CALF;AAOD,CAbM","names":["resolveFetch","customFetch","_fetch","fetch","args","then","default","resolveResponse","__awaiter","Response","recursiveToCamel","item","Array","isArray","map","el","Object","result","entries","forEach","key","value","newKey","replace","c","toUpperCase","isPlainObject","prototype","getPrototypeOf","Symbol","toStringTag","iterator"],"sources":["/Users/johann/node_modules/@supabase/storage-js/src/lib/helpers.ts"],"sourcesContent":["type Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = (...args) =>\n      import('@supabase/node-fetch' as any).then(({ default: fetch }) => fetch(...args))\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\nexport const resolveResponse = async (): Promise<typeof Response> => {\n  if (typeof Response === 'undefined') {\n    // @ts-ignore\n    return (await import('@supabase/node-fetch' as any)).Response\n  }\n\n  return Response\n}\n\nexport const recursiveToCamel = (item: Record<string, any>): unknown => {\n  if (Array.isArray(item)) {\n    return item.map((el) => recursiveToCamel(el))\n  } else if (typeof item === 'function' || item !== Object(item)) {\n    return item\n  }\n\n  const result: Record<string, any> = {}\n  Object.entries(item).forEach(([key, value]) => {\n    const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ''))\n    result[newKey] = recursiveToCamel(value)\n  })\n\n  return result\n}\n\n/**\n * Determine if input is a plain object\n * An object is plain if it's created by either {}, new Object(), or Object.create(null)\n * source: https://github.com/sindresorhus/is-plain-obj\n */\nexport const isPlainObject = (value: object): boolean => {\n  if (typeof value !== 'object' || value === null) {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return (\n    (prototype === null ||\n      prototype === Object.prototype ||\n      Object.getPrototypeOf(prototype) === null) &&\n    !(Symbol.toStringTag in value) &&\n    !(Symbol.iterator in value)\n  )\n}\n"]},"metadata":{},"sourceType":"module"}